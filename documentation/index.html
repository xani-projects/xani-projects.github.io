<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="My second, super-cool, Jekyll-powered blog.">
    <title>Техническая документация реализации сервиса I-Found?</title>
    <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
    <link rel="icon" type="image/png" sizes="192x192"  href="/icons/android-icon-192x192.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
    <link rel="manifest" href="/icons/manifest.json">
    <meta name="msapplication-TileColor" content="#ffffff">
    <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
    <meta name="theme-color" content="#ffffff">

     <script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
            m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-93484749-1', 'auto');
        ga('send', 'pageview');

    </script>

    <script>
        var trackOutboundLink = function(url) {
            ga('send', 'event', 'outbound', 'click', url, {
                'transport': 'beacon',
                'hitCallback': function(){document.location = url;}
            });
        }
    </script>
    <link href="/css/bootstrap.css" rel="stylesheet" type="text/css">
    <link href="/css/font-awesome.min.css" rel="stylesheet" type="text/css">
    <link href="https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" rel="stylesheet" type="text/css">
    <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800"
          rel="stylesheet" type="text/css">
    <link href="/css/landing.css" rel="stylesheet" type="text/css">
    <script src="/js/jquery.min.js"> </script>
</head>
<body>
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                <span class="sr-only">Toggle navigation</span>
                Меню <i class="fa fa-bars"></i>
            </button>
            <a class="navbar-brand" href="/">I-Found</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
            <ul class="nav navbar-nav navbar-right">
                <li>
                    <a href="/donate/">Помощь проекту</a>
                </li>
                <li>
                    <a href="/documentation/">Тех. документация</a>
                </li>
                <li>
                    <a href="/volunteers/">Волонтёры</a>
                </li>
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<header class="large-header intro-header" style="background-image: url('/img/home-bg.jpg')">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="site-heading">
                    <h1>I-Found</h1>
                    <hr class="small">
                    <span class="subheading">Сервис для поиска пропавших людей</span>
                </div>
            </div>
        </div>
    </div>
</header>
<div class="container">
    <div class="row">
        <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1 content">
            <h2>Техническая документация</h2>
<p>Разработка данного сервиса будет достаточно интересной задачей. Описать проект можно двумя словами: легкий, но
    сложный. Теперь подробнее.
    <br/>Первое, что мы точно решили - это растащить бэкенд и фронт, полагаясь на технологию SSR (server-side
    rendering). Решение основывается на том, что мобильное приложение является основным фронтом для бэкенда. Поэтому
    делаем один API-сервер для web и приложений. А HTML для браузеров отдаём через SSR. Можно, разумеется, даже не
    строить dom со стороны сервера. Но SEO диктует свои правила, как и поддержка браузеров без js или где с
    react(vue.js) могут возникнуть проблемы. Как вы заметили, мы думаем использовать react или vue.js, выбор опять же из
    за функциональности и возможностей. Лично я бы склонялся в сторону vue, тк ssr на ней быстрей. Но react более
    масштабируемый и функциональный. С другой стороны, есть preact. Имеющий аналогичный api react, который по скорости
    ssr не уступает vue.js. Но это всё надо тестировать и делать выводы, что больше нам подойдет. Определившись с тем
    что мы разнесли бэкенд и фронт, стоит теперь сказать про api составляющую. Первое: обмен будет строиться скорее
    всего на rest api + socket.io. Да, мы можем полностью отказаться от rest и перейти на сокеты. Но тут спорный вопрос,
    который мы даже не хотим обсуждать. Проблема, наверное, в самих сокетах. Проблема в том, что socket.io имеет своих
    “тараканов” при работе с ним. А без него у нас не будет fallback на ajax или flash. И всё очень непонятно. И да, мы
    слышали о comet, tornado и тпд. С другой стороны, если мы будем делать rest, то почему бы нам не остановится на sse
    (server side event). То есть события принимаем по sse, а всё остальное идёт по rest. Выглядит хорошо, но опять же -
    fallback и старые браузеры. В общем, пока мы смотрим в сторону rest api + socket.io. Еще один довольно сложный
    вопрос - выбор базе. Остановились на postgresql. Во-первых, она реляционная, что даёт нам связи между записями.
    Во-вторых, она точно стабильна. В-третьих, есть bson. Почему не mysql? Вопрос сложный. Но как факты oracle, mariadb
    и percona. Сокращая всё это, непонятно какую именно реализацию использовать, и если крутить что то типа bson, то там
    всё, насколько нам известно, не очень хорошо по сравнению с postgresql - тогда нам придётся брать ещё, допустим,
    mongodb. Почему не тот же mongodb или другая документарная база? С одной стороны, да можно, но опять же вспомним,
    что большинство вещей связаны между собой и реляционная модель подходит лучше. Как пример - ошибка в проектировке
    базы данных диаспоры <a href="https://habrahabr.ru/post/231213/"
                            onclick="trackOutboundLink('https://habrahabr.ru/post/231213/'); return false;">статья про
        диаспору</a>. Но есть и плюсы, о которых чуть позже. На этом обсуждение базы не закончено. Почему? Да потому,
    что данных предполагается мало. Сколько данных хранится в
    записе о пропавшем человеке? Не так уж и много. Тем более, в нашем проекте предполагается две части: кратковременный
    поиск и долгосрочный. Отличие лишь во времени. Приложение создано для кратковременного поиска (3-7 дней ещё не
    определились до конца) , а долгосрочный уже идёт как база данных и сайт. То есть если ещё не прошёл 3-7 дней, то это
    одна база, на которую будет ложиться основная нагрузка. А если этот срок прошел, то это уже база разыскиваемых
    больше недели, скорее напоминающая “Жди меня”. Но нас интересуют обе составляющие, чтобы у ищущих не было проблем с
    долгосрочным поиском, и, само собой разумеющееся, помощь при краткосрочном поиске. И тут можно сказать следующее:
    из-за количества данных, краткосрочный поиск можно переложить полностью на memory database. Это даст прирост в
    производительности, тем не менее потребует достаточно большое, но приемлемое количество озу. Поэтому, мы думаем, что
    писать будем сразу в обе базы - краткосрочную и долгосрочную. В этом случае, долгосрочная является бэкапом и
    самостоятельной базой, а краткосрочная быстрым хранилищем в 7 дней, которое легко чистить. Но выбрать достойную
    memory database будет сложно. Если у кого-то есть мысли по этому поводу - напишите нам в группе вк. И да, про
    tarantool мы слышали, но подробностей этой дб не знаем. Кто может рассказать как она на практике, обращайтесь также
    в группу, будем благодарны. С базой и протоколами разобрались, переходим к самому сложному вопросу. Язык для
    бэкенда. Разумеется, что для ssr это node.js, как react так и vue.js. Это не обсуждается. А вот для api с языком
    проблема. Разумеется, изначальная ошибка с выбором языка обернется катастрофой. И поэтому, по нашему мнению, есть
    три достойных кандидата: node.js, php (laravel), python (django-rest). Почему мы откинули ror, java(spring) или
    другие? Объяснять все не будем, но ror много ест, да и в рест с сокетами сложно переводить - не на то он нацелен.
    Java слишком много ест… Очень много… А мейнфреймы - это не наш стиль. Asp.net c# - это windows, а значит и лицензия
    ос. Хотя они круты, мы не отрицаем. И да, есть mono и запуск под linux, но стоит ли оно того? Поэтому и остаются эти
    языки. Конечно, php и python старички. Но они до сих пор актуальны, и строить архитектуру бэкенда на них очень
    легко. В тоже время node.js молодая, но, что для нас немаловажно, асинхронная (точнее неблокирующий io, но тут уже
    сами смотрите). Она на javascript и уже у нас используется. С коробки держит сокеты и очень шустра. Но она на
    javascript, что само собой и плюс и минус. Архитектура достаточно путаная получается, но неблокирующий io говорит
    сам за себя, тем более мы её уже используем. С другой стороны, она однопоточная, и поднимать её кластер тоже спорное
    решение. Но если python и сам может сокеты жевать, то для php нам придётся делать для сокетов прослойку между php и
    node.js. То есть rest, работу с бд и всё кроме сокетов берёт на себя php. А node.js принимает сокеты и вызывает php.
    Обычно для socket.io используют схему php - redis - node.js - socket.io. С другой стороны, один лишь laravel или
    zend стоят рассмотрения php как языка для бэкенда, тем более с выходом php 7, а также hhvm. Вспоминая python, на ум
    сразу приходит лишь одно - django. А в нашем случае его модификация django-rest-framework. Очень мощный фреймворк.
    Язык не имеющий проблем с точки зрения архитектуры и масштабирования. А также из коробки сокеты в отличии от php. Ну
    и самом собой jit компиляция с неплохими выходными результатами. Но найти хороших специалистов сложно и стоят они
    очень дорого. Не говоря о том, что как c php так и с python, мы “плодим” языки, тк мы точно будем использовать
    node.js из-за ssr. Можно было бы отказаться от ssr, но тогда у нас бы появилась проблема с фронтом, чего очень не
    хочется. Хотя мы и понимаем, что хорошего специалиста в react (vue.js) найти сложно. Но оно того стоит. Для нашего
    проекта, где основная нагрузка должна идти на api сервера. Что позволяет react(vue.js).
    <br/>Переходя к другим подробностям, скажем следующее: разумеется у нас будет ssl. Иначе к нам не будет доверия. Кто
    не понял о чём речь, то мы говорим о https. И, разумеется, если https, то глупо использовать HTTP/1.1. Он крут, но в
    скорости проигрывает 2-ке при ssl из-за количества headers и непостоянного канала. Поэтому наш выбор ssl и 2
    реализация протокола http или его аналог, допустим, spdy. Следующим вопросом стоит uptime, распределение нагрузки на
    сервера и сохранность данных. Не стоит говорить, что сервис бесполезен если “лежит”. Поэтому необходимо обеспечить
    максимальный uptime. Сначала надо распределить нагрузку на сервера. За это будет отвечать haproxy. Опыта работы с
    ним нет, но он лучший в этой сфере. Если мы ошибаемся - пишите в группу вк. Разумеется, если мы получим маленький
    бюджет, о нём и речи быть не может, тк в распределении не будет необходимости. И с этим справится даже nginx,
    который, кстати, мы выбираем как основной web сервер. Haproxy должен отвечать за ssl и распределение нагрузки, с
    этим он справляется на ура. Хотя мы думаем, что, возможно, стоит использовать аппаратное шифрование. Но опять же для
    старта можно и без них. Как и надобность в таком сомнительная, не говоря о том, что мы не знаем их эффективность и
    если кто сможет рассказать об этом, будем очень рады вашим советам. На счёт Nginx, думаю, даже не стоит рассказывать
    - он просто стабилен и делает что нужно. Вопрос лишь в том, стоит ли перед ним ставить varnish, предназначение
    которого в отдаче статики из озу. Повторимся, что данных не так много (файлы в принципе только статика и фото
    пропавших), и в озу они прекрасно помещаются в краткосрочном сервере. И чтобы не наси…. Кхм не использовать попусту
    ресурсы жестких дисков, а также ради максимально быстрых ответов. Мы думаем использовать как раз таки memory db и
    varnish. Но производительность varnish у нас под сомнением. При локальных тестах без высокой нагрузки он проигрывает
    обычному nginx + ssd. Но решение старое и проверенное многими. Вопрос в том, что его стоит заново протестировать и
    также придумать схему очистки при переходе заявки в долгосрочный поиск. Кстати, на счет файлов, мы смотрим в сторону
    hdfs из hadoop. Из-за одной особенности - это фс, которая не даёт ни в коем случае удалить файл. Да, у неё свои
    плюсы и минусы, но тот факт, что если что-то попало в неё уже точно не удалится, подходит нам на все 100%. Конечно,
    мы также думаем о возможности хранения в xfs, тк она быстрая. Но тогда стоит быть очень осторожными. И тут многие
    скажут: “Вы не правы!” Вспомните про mongodb, которая масштабируемая и хранит бинарники на раз два. О чём мы и
    говорили: если выбирать mongodb, то мы обеспечиваем хранилище файлов. Но выборка из бд - это всё равно прослойка, и
    статику так нехорошо отдавать. Поэтому мы можем рассмотреть такой вариант как xfs + mongodb. Но от реляционных
    связей так просто не откажешься. Да и, в данном случае, mongo выступает лишь как бэкап. То есть к нам приходит
    запрос varnish, ищет файл в озу. Если нет - передает управление nginx. Тот, в свою очередь, смотрит в xfs. И если
    его и там нет - запрашивает его у бэкенда, который пытается восстановить его из mongodb, если, разумеется, там его
    находит. Иначе 404. Ну да ладно, оставим тему фс в покое. Следующим вопросом становится автодеплой и развертывание
    серверов. Для этого мы хотим использовать ansible и docker. То есть, сводя к минимуму, берем минимальный linux
    дистрибутив. Ставим туда ansible и уже через него тянем докер и делаем все манипуляции. Он отвечает за все
    манипуляции на хосте. И да, есть аналоги, допустим, chef puppet. Но мы в них плохо разбираемся, и совет бы нам не
    помешал. А на ansible пал выбор, тк его зачастую используют с докером. Вопрос по поводу докера даже не обсуждался:
    это удобно. Хотя, официально, это cgroups с изоляцией пространства имён. Легче всего его сравнить с chroot или же
    неполной виртуализацией. Хотя это совсем не одно и тоже, но для аналогии некоторым людям более понятно. Мы бы могли
    тянуть kvm, openvz или аналоги. Но это ест куда больше ресурсов, что само по себе не ахти. Не говоря о том, что
    конфиги докера удобны. Мы не искали аналоги, но всё построено на lxc. Так что если у вас есть мысли по аналогам или
    предложения лучше, то мы всегда вам рады. Что не очень хорошо во всём этом. Это всё удобно и хорошо настраиваемо, но
    требует внедрения и первоначальная конфигурация достаточно проблематичная. Плюсы, правда, все эти проблемы
    перекрывают. Кроме одной. Чтобы сделать это грамотно нужен человек, разбирающийся в этом. А это деньги. Тем более,
    специалистов в этом очень мало, что само собой поднимает цену. Можно самим изучить. Но тогда нам, как минимум, нужен
    системный администратор linux, который изначально знает достаточно много и понимает структуру *nix подобных ос. То
    есть человек, который может перекомпилировать ядро, не является нашим выбором. Он, как минимум, должен разбираться в
    технологиях. Как минимум иметь опыт оптимизации tcp/ip стека под высокую нагрузку. Не говоря о таких банальных вещах
    как настройка nginx etc. Хоть и не идеально, но должен иметь достаточный опыт. И сколько таких спецов? Особенно,
    учитывая, что ему придётся разбирать доки(маны) к ansible и docker. Ну да ладно, хватит об этом, возвращаясь назад,
    можно сказать, что в остальном эти продукты замечательны, кроме одного фактора. Люди очень не советуют использовать
    в докере базы данных и фс. Причины на то тоже есть. Для баз данных это две причины. Первая проблема: обновление базы
    данных. Вторая - прослойка фс замедляет работу хоть и незначительно. А вот, допустим, с hdfs имеет ли смысл делать
    прослойку между прослойкой. Грубо говоря у самого докера есть прослойка между ним и фс хоста. А мы ещё одну фс туда
    суём. Не легче ли его на хост систему поставить и обойтись без задержек из за этих прослоек? Тут вопрос спорный, всё
    зависит от количества серверов, которые мы сможем получить. А это зависит от денег, думаю, и так ясно. И если бд в
    докере выглядит ещё нормально, хоть и с проблемами по части обновления, то фс выглядит не очень. С другой стороны,
    непонятно как автоматизировать поднятие хост ос с ansible. Да есть такие вещи как pxe. Но сможем ли мы поднимать с
    помощью него ос у хостинг провайдеров? Иметь же свой датацентр, по нашему мнению, не логичное решение. Тут мы будем
    особенно рады советам и практикам. Почему бы не использовать kvm, вопрос отпадает. Думаю, и так понятно, что
    виртуализация на “дедике” для докера глупое решение. Тк докер является заменой обычной виртуализации. Как и брать не
    весь “дедик”, а только часть от него.
    <br/>Кстати на счёт “дедиков”. Исходя из всего вышесказанного, можно уже сделать выводы по минимальному количеству
    серверов. Разумеется, мы не говорим об одном. Тк и так ясно, что всё это можно запустить и на одном. Но если он
    выйдет из строя - у нас отключение всей системы. И это проблема. Для обеспечения отказоустойчивости нам необходим,
    как минимум, дублирующий сервер, который можно организовать с помощью таких технологий как
    <a href="https://ru.wikipedia.org/wiki/CARP"
       onclick="trackOutboundLink('https://ru.wikipedia.org/wiki/CARP'); return false;">carp</a> , ucarp или аналогов.
    Выбор которых также может зависеть и от оборудования
    стоящего перед серверами. Казалось бы, всё хорошо. Но, первое: между двумя серверами уже можно проводить
    балансировку нагрузки. Второе - неплохо было бы, как минимум, разнести ssr и api. Получаем ещё 2 сервера под ssr и 2
    минимальных сервера под haproxy. В конечном счёте, желательным минимумом будет 6 серверов и 2 под haproxy, задача
    которых распределять нагрузку, ещё 2 под ssr. С основным требованием в виде очень шустрого процессора и вменяемым
    количеством озу. И последние 2 под api, где основным требованием идёт озу и сетевые интерфейсы. Озу, потому что мы
    хотим хранить всё в озу. А сетевые интерфейсы сейчас объясним. Давайте посчитаем. Берём Россию, любой город
    миллионник, где, допустим, 15% населения имеет приложение. Если хотя бы треть из них будет в сети, получаем цифру в
    50 к коннектов по сокетам. А таких городов в россии не мало. И 100 - 200 к коннектов должно быть для системы
    нормально. Конечно, они висят и ничего в основном не делают, ждут событий. Но само количество и скачкообразный
    принцип их поведения немного настораживает. Кстати говоря, разумеется, можно выкинуть haproxy. Тем более что домены
    будут скорее всего раскиданы по типу i-found.ru и api.i-found.ru. И с распределением нагрузки прекрасно справится
    nginx. Но haproxy является хорошим задатком на будущее. Хотя его необходимость и спорная. Но самым интересным во
    всей этой системе становится тот факт, что узкими местами (бутылочным горлышком), скорее всего, будут две вещи.
    Сокеты, тк их количество в полностью работоспособной системе зашкаливать за миллион. Озу, а точнее его количество.
    Если мы будем использовать memory db. Но если мы не используем memory db для краткосрочного поиска, то, разумеется,
    у нас станет узким местом база данных. Но также появится другая проблема. Или сливать вместе краткосрочную бд с
    долгосрочной. Или же постоянно удалять из первой записи и делать оптимизацию таблиц. В общем наш выбор всё-таки
    использовать больше озу. Тем более она не такая уж и дорогая по сравнению с давними временами. Не говоря о том, что
    количество информации по пропавшим за 7 дней не такое уж и большое. А от varnish или memory fs, в крайнем случае,
    можно и отказаться.

</p>
<h2>Приложение</h2>
<p>Ну а теперь самое долгожданное. Мы всё говорили о бэкенде и фронте для web. Пришло время сказать как же будет
    работать приложение. Да, там всё достаточно легко. Реализовывать будем на нативных для устройств языках -
    обусловлено необходимостью держать “фоновый процесс”. А также минимальным потреблением ресурсов устройства. Да,
    многие могли бы сказать: “У вас есть react зачем вам “нативка”? Пишите на react native, тем более, у вас, скорее
    всего, разработчик в этом будет”. Но react native слишком молод и сыр. Не говоря уже о сложностях работы с фоновым
    процессом и потреблением ресурсов. Не говоря о других подобных решениях на webview (apache cordova и все его детки с
    phonegap). Не говоря уже о таких товарищах, как ionic framework, основанный на angular. Они просто слишком много
    едят и работа с фоновыми процессами печальная. Особенно в случае webview based технологий. Где обработка всего идёт
    через js. Поэтому только “хардкор”. То есть пишем на нативных языках. И да, мы не отрицаем полезность подобных
    технологий. Но в нашем случае они не подходят. Если мы их будем использовать, то будет очень много недовольных людей
    из-за того, что их мобильники стали работать значительно медленнее или приложение слишком долго открывалось. С
    языком определились. Что же по поводу обмена между приложением и бэкендом? Тут всё достаточно легко, но есть одна
    особенность. Эта особенность заключается в том, с какой стороны обрабатывать, что посылать клиенту, а что нет? Наш
    выбор: посылаем всё, а устройство само решит, что ему нужно! С одной стороны, это увеличит нагрузку на мобильник. И
    с первого взгляда нагрузку на сеть, то есть на сокеты, что увеличит количество трафика. Но это только с первого
    взгляда. Вспомним, какие случаи оповещения есть? Оповещать всегда. Схема идеально вписывается. Оповещать, в случае,
    если кто-то пропал возле места, где я часто бываю. Тоже вписывается, но если бы сервер решал, что отправлять, а что
    нет - мобильнику бы приходило меньше. И третий случай - это навигация. А вот тут стоп. При навигации, если мы будем
    отправлять с сервера инфу, то всё ок. На устройстве просчитываем, вступаем мы сейчас в зону поиска или нет. Но если
    обратную схему брать, то мы будем посылать серверу постоянно наше местоположение, чтобы тот решил, входим мы в зону
    или нет. Что не очень хорошо сказывается на конфиденциальности клиентов, а также значительно увеличивает количество
    передаваемой информации. Да и тем более сколько людей может пропасть в городе за 3 - 7 дней? Не так много, чтобы
    нагрузить любое устройство. Если вы пролистали немного ленту ВКонтакте, вы скорее всего получили больше информации.
    Поэтому, чтобы сохранять как можно больше анонимность к клиенту, а также в целях снижения нагрузки на канал и api
    сервера, клиентам будет отправляться вся информация. А устройства уже будут решать выдавать им уведомление или нет.
    Что достаточно удобно и в случае обновления настроек на клиенте. Если, допустим, он выведет отображать все ему сразу
    выводятся все уведомления. Единственная проблема - это синхронизация данных между клиентом и сервером, которая имеет
    слишком много реализаций, и к конкретному паттерну или реализации мы не присмотрелись. Если есть мысли пишите. На
    счёт формата данных ясно json, а вот api можем привести только пример. Оно не доработано и будет зависеть от
    возможностей которые сможем реализовать. Да и тем более, любой понимающий человек может прикинуть, как оно должно
    выглядеть, ничего сложного. Как пример, для оповещения нам нужны следующие данные: фамилия, имя, возраст, дата,
    ссылка на фото, а также координаты. Это минимально необходимые данные.
    <img src="/images/json.png"/>
    <br/>
    Имя, фамилия, думаем, ясно зачем нужны. Возраст, дата и координаты влияют на систему оповещения. А ссылка на фото
    для того, чтобы в уведомлениях было превью. Если нет фото то false. Что тоже значительно влияет на систему
    оповещения. Помните это только пример.
    <br/>
    Приложения, а также api будут открыты. То есть у приложений открыт исходный код. А серверное api доступно для
    создания других приложений. Также предполагается server - server api. Для того чтобы сайты волонтёрских групп или
    новостные порталы городов могли забирать данные для публикации.
</p>
<h2>Нейронные сети</h2>
<p>Да, вы не ослышались, нейронные сети. Мы хотим найти сеть натренированную на распознование лиц. Такая, допустим, есть
    у русских ребят из <a href="https://findface.ru/"
                          onclick="trackOutboundLink('https://findface.ru/'); return false;">findface.ru</a> . Признанная одной из лучших. Поэтому можно попытаться взаимодействовать или
    “натренировать” свою. Ну да к чему мы ведем и зачем она нам. Первое: взаимодействие между гос. органами
    очень плохое и пропавших людей давно уже нашли, но просто данные где-то потерялись. Второе: это может быть быстрее,
    чем сравнение человека. Третье: пройтись по базам данных пропавших и людей, непомнящих кто они. Сопоставление может
    дать неожиданные результаты. То есть мы берём базу тех кто потерял память и сопоставляем с теми кто потерялся. А в
    дальнейшем переводим на постоянную основу эту систему. Но что про взаимодействие? Если вкратце, то следующее. Есть
    следующие пункты, где человек может оказаться: морг, больница, вытрезвитель и сизо. И все эти данные должны
    поступать в полицию, а какой-то сотрудник должен их сверять. Ну и тут проблема взаимодействие между ними налажено,
    насколько нам известно, достаточно плохо. Но даже если бы было хорошо, это никак не быстрее нейронной сети. То есть,
    в случае поступления человека в бессознательном состоянии, без памяти или же в случае смерти. Организация его
    фотографирует, и это фото поступает в систему, где нейронная сеть пытается его найти, а уже потом, в случае провала,
    обработка передается человеку. Но не отменяя сравнение с поступающими заявками.
</p>
<h2>Подводя черту</h2>
<p>У сервиса, с одной стороны, легкая реализация, с другой стороны, много особенностей. Есть особенности обработки и
    хранения информации. Сложный выбор языка для бэкенда. Мы не учитывали такие языки как scala или go(golang), потому
    что мало о них знаем. Но не берём в расчёт full stack framework javascript такие как meteor. Считая что они уж точно
    под такую задачу не подходят. Будем пытаться найти подходящую memory db. И, в крайнем случае, используем postgresql
    для обеих реализаций. Но в тоже время мы должны очень сильно задуматься по поводу бэкапирования и отказоустойчивости
    системы в целом. Потому что в отличии от соц. сетей, допустим, у нас запись это не пост. Потеря которого не так
    страшна. А запись представляет собой потерявшегося человека. Мы понимаем важность привлечения к изначальной
    разработке хорошего системного администратора. Потому что программисты пишут, а админы развёртывают зачастую
    “плюясь”. И они намного лучше нас могут сказать, что тут мы ошибаемся, а вот это лучше этого. Также как понимаем
    важность ssr и хорошего но лаконичного фронта. И если раньше фронт недооценивали, то теперь он не менее важен чем
    бэкенд. А хороших специалистов в нём мало.
    <br/>Принимая во внимание всё что было написано, мы получаем что для реализации нам бы не помешали или необходимы
    следующие специалисты:
<ul>
    <li>linux системный администратор;</li>
    <li>react(vue.js) разработчик;</li>
    <li>верстальщик;</li>
    <li>ios и android разработчики;</li>
    <li>бэкенд разработчик;</li>
    <li>специалист в базе данных postgresql;</li>
    <li>дизайнер web и приложений.</li>
</ul>
Да, без верстальщика, админа и дизайнера можно стартовать. Фронтовик может накидать и вёрстку. И многие скажут, что это одно и тоже. Но нет -  фронтовик на react может офигенно знать react и как строить на нём логику или реализовывать приложение. Но намного меньше знать верстку хотя и хорошо, но без тонкостей. Без чего уж точно не обойдёмся - это ios и android разработчики, заменить нам их некем. По части дизайна на устройствах, мы попытаемся использовать максимально нативный и понятный для конкретного устройства. А с web стороны, думаем использовать хорошо продуманный в стиле material design.  Бэкенд может написать один из нас. Как и фронт накидать на vue.js. Но не того уровня, который необходим.
Как понятно, ни к чему хорошему это не приведёт и лучше сразу сделать всё как нужно. А не как обычно. Поэтому, если есть люди желающие помочь, будем очень рады. Мы не знаем какой будет бюджет: всё зависит от пожертвования,  из-за этого и такой разброс.
Также само собой разумеющееся нам нужны следующие специалисты:
<ul>
    <li>seo;</li>
    <li>копирайтер.</li>
</ul>
То есть люди ответственные за текст и  продвижение.


        </div>
    </div>
</div>
<hr>
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                    <li>
                        <a target="_blank" href="https://twitter.com/XaniProjects" onclick="trackOutboundLink('https://twitter.com/XaniProjects'); return false;">
                                <span class="fa-stack fa-lg">
                                    <i class="fa fa-circle fa-stack-2x"></i>
                                    <i class="fa fa-twitter fa-stack-1x fa-inverse"></i>
                                </span>
                        </a>
                    </li>
                    <li>
                        <a target="_blank" href="https://vk.com/xaniprojects" onclick="trackOutboundLink('https://vk.com/xaniprojects'); return false;">
                                <span class="fa-stack fa-lg">
                                    <i class="fa fa-circle fa-stack-2x"></i>
                                    <i class="fa fa-vk fa-stack-1x fa-inverse"></i>
                                </span>
                        </a>
                    </li>
                    <li>
                        <a target="_blank" href="https://www.facebook.com/Xani-projects-1835218020085526/" onclick="trackOutboundLink('https://www.facebook.com/Xani-projects-1835218020085526/'); return false;">
                                <span class="fa-stack fa-lg">
                                    <i class="fa fa-circle fa-stack-2x"></i>
                                    <i class="fa fa-facebook fa-stack-1x fa-inverse"></i>
                                </span>
                        </a>
                    </li>
                    <li>
                        <a target="_blank" href="https://github.com/xani-projects"  onclick="trackOutboundLink('https://github.com/xani-projects'); return false;">
                                <span class="fa-stack fa-lg">
                                    <i class="fa fa-circle fa-stack-2x"></i>
                                    <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                                </span>
                        </a>
                    </li>
                </ul>
                <p class="copyright text-muted">email: <a href="mailto:xaniprojects@gmail.com">xaniprojects@gmail.com</a></p>
                <p class="copyright text-muted">Copyright © Xani-Projects 2017 </p>
            </div>
        </div>
    </div>
</footer>
<script src="/js/bootstrap.min.js"> </script>
<script src="/js/navigation.js"></script>
</body>
</html>